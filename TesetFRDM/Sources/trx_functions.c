/*
 * trx_functions.c
 *
 *  Created on: Jun 5, 2014
 *      Author: Kaustubh
 *      
 *      This file contains all the basic functions used for communication between MCU and Si4463 making use of the spi functions in trx.c. 
 */


#include "PE_LDD.h"
#include "TRX_SCLK.h"
#include "TRX_SDI.h"
#include "TRX_SDO.h"
#include "TRX_nSEL.h"
#include "trx.h"
#include "trx_functions.h"
#include "radio_config_Si4460.h"

READTRX READ;


int trx_sendcmdnoreply(uint32_t *cmd, int length )
{
	int i=0;
	int counter=0;
	trx_spi_transfer(0x44);
	trx_spi_transfer(0xFF);
	trx_spi_end_transaction();
	unsigned char CTS=0x00;
	for (i=0;i<length;i++)
	{
		
		trx_spi_transfer(*cmd);
		cmd++;
		
	}
	trx_spi_end_transaction();
	trx_spi_transfer(0x44);
	CTS=trx_spi_transfer(0xFF);
	trx_spi_end_transaction();
	while(!CTS)
	{		
	trx_spi_transfer(0x44);	
	CTS=trx_spi_transfer(0xFF);
	trx_spi_end_transaction();
	counter++;
	}
	trx_spi_end_transaction();


return 1;

}

int trx_spi_sendcmdwithreply(uint32_t *cmd,uint32_t * rep,int cmd_len, int rep_len)
		{
		int i=0;
		int counter=0;
		trx_spi_transfer(0x44);
		trx_spi_transfer(0xFF);
		trx_spi_end_transaction();
		unsigned char CTS=0x00;
		for (i=0;i<cmd_len;i++)
		{
			
			trx_spi_transfer(*cmd);
			cmd++;
			
		}
		trx_spi_end_transaction();
		trx_spi_transfer(0x44);
		CTS=trx_spi_transfer(0xFF);
		
		while(!CTS){
		trx_spi_end_transaction();
		trx_spi_transfer(0x44);		
		CTS=trx_spi_transfer(0xFF);		
		counter++;
				}
		for (i=0;i<rep_len;i++)
		{	
		*rep=trx_spi_transfer(0xFF);
		rep++;
		}
		trx_spi_end_transaction();
		return 1;
		}

int trx_initialize()
{
		uint32_t r, ri;
	 // Initializing all GPIO pins
	  TRX_nSEL_Init((void *)0);
	  TRX_SDI_Init((void *)0);
	  TRX_SCLK_Init((void *)0);
	  TRX_SDN_Init((void *)0);
	  LED_red_Init((void *)0);
	  LED_red_SetVal((void *)0);
	  TRX_SDO_Init((void *)0);
	  TRX_SCLK_SetVal((void *)0);
	  TRX_SDN_SetVal((void *)0); 
	  TRX_nIRQ_Init((void *)0);
	  int d;
	  for (d=0;d<3300000/2;d++)
	  {}
	  TRX_SDN_ClrVal((void *)0);
	  TRX_SCLK_ClrVal((void *)0);
	  for (d=0;d<5500;d++){}
	 
	 // power up the radio
	 uint32_t ModemTrx1[] = {RF_POWER_UP};
	 
	
	 //uint32_t ModemTrx3[]= {RF_Read_Info};
	 trx_sendcmdnoreply(ModemTrx1,7);
	 
	 //clear the interrupt generated by boot up
	 uint32_t ModemTrx2[]= {RF_Clear_Interrupt_Flag};
	 	
	 trx_spi_sendcmdwithreply(ModemTrx2,&ri,4,9);
	 uint32_t a=0x01;
	 trx_spi_sendcmdwithreply(&a,&r,1,7);
	 // Enable the interrupts
	 uint32_t it[]={RF_INT_CTL_ENABLE_2};
	 trx_spi_sendcmdwithreply(it,&r,8,1);
	 //Configuring the GPIO pins
//	 uint32_t gpio[]={RF_GPIO_PIN_CFG};
//		trx_spi_sendcmdwithreply(gpio,&r,8,1);

	 // configuring the radio now
	
			 	 
		uint32_t da=0x33;
		trx_spi_sendcmdwithreply(&da,&r,1,3);
	 	 
			 	
		uint32_t ModemTrx3[]={RF_PREAMBLE_TX_LENGTH_1};
		uint32_t ModemTrx4[]={RF_PREAMBLE_CONFIG_1};
		uint32_t Mode[]={RF_MODEM_MOD_TYPE_12};
		uint32_t CLKGEN[]={RF_MODEM_CLKGEN_BAND_1};
		uint32_t synth[]={RF_SYNTH_PFDCP_CPFF_7};
		uint32_t freq_int[]={RF_FREQ_CONTROL_INTE_8};
		uint32_t ramp[]={RF_MODEM_TX_RAMP_DELAY_8};
			 			 	 
		trx_spi_sendcmdwithreply(Mode,&r, 16,1);
		trx_spi_sendcmdwithreply(CLKGEN,&r,5,1);

		trx_spi_sendcmdwithreply(synth,&r,11,1);

		trx_spi_sendcmdwithreply(freq_int,&r,12,1);

		trx_spi_sendcmdwithreply(ramp, &r,12,1);
		
//		uint32_t rxprop1[]={RF_MODEM_CHFLT_RX1_CHFLT_COE1_7_0_12};
//		trx_sendcmdnoreply(rxprop1,16);
//		
//		
//		
//		uint32_t rxprop2[]={RF_MODEM_CHFLT_RX1_CHFLT_COE13_7_0_12};
//		trx_sendcmdnoreply(rxprop2,16);
//		
//		uint32_t rxprop3[]={RF_MODEM_CHFLT_RX2_CHFLT_COE7_7_0_12};
//		trx_sendcmdnoreply(rxprop3,16);
//
//		uint32_t rxprop4[]={RF_MODEM_BCR_OSR_1_9};
//		trx_sendcmdnoreply(rxprop4,13);
//		
//		uint32_t rxprop5[]={RF_MODEM_AFC_GEAR_7};
//		trx_sendcmdnoreply(rxprop5,13);





		//set PA mode
			 			 	 
		uint32_t PA[]={RF_PA_MODE_4};
		trx_spi_sendcmdwithreply(PA, &r,8,1);

		
		//configure the preamble length
		trx_spi_sendcmdwithreply(ModemTrx3,&r,5,1);
			 			 	 
		//select the preamble config 
		trx_spi_sendcmdwithreply(ModemTrx4,&r,5,1);
			 			 	 
			 			 	 

		//select the sync config
			 			 	 	 
		uint32_t sync[]={RF_SYNC_CONFIG_3};
		trx_spi_sendcmdwithreply(sync,&r,7,1);
			 			 	 
		//select the packet configuration 
		uint32_t packet[]={RF_PKT_CONFIG1_1};
		uint32_t packetlength[]={RF_PKT_FIELD_1_CONFIG_1};
		trx_spi_sendcmdwithreply(packetlength,&r,5,1);
		trx_spi_sendcmdwithreply(packet,&r,5,1);
		// set internal capacitor frequency
		uint32_t XO[]={RF_GLOBAL_XO_TUNE_1};
		trx_spi_sendcmdwithreply(XO, &r,5,1);
				
				
		uint32_t write[]={0x34,0x01};
		trx_spi_sendcmdwithreply(write,&r,2,1);
		delay(2000);
		trx_transmit();
return 1;}

int trx_transmit()
{			uint32_t r;
		 	 while(1){
		 		
	 	 //change the state to TX
		 	 uint32_t write[]={0x34,0x07};
//		 	 trx_spi_sendcmdwithreply(write,&r,2,1);
		 	 // Building the payload
		 	 uint32_t data[9];
		 	 data[0]=0x66;
		 	 data[1]=0x55;
		 	 data[2]=0x54;
		 	 data[3]=0x54;
		 	 data[4]=0x54;
		 	 data[5]=0x54;
		 	 data[6]=0x54;
		 	 data[7]=0x0D;
		 	 
		 	
		 	  trx_sendcmdnoreply (data,8);

		 	 //start TX
		 	 
		 	 uint32_t tx[5];
		 	 tx[0]=0x31;
		 	 tx[1]=0;
		 	 tx[2]=0x10;
		 	 tx[3]=0;
		 	 tx[4]=0x08;
		 	 
		 	trx_spi_sendcmdwithreply(tx,&r,5,1);
		 	  
		 	
		 	while(TRX_nIRQ_GetVal((void *)0))
		 	{
		 		
		 		
		 	}
		 	 uint32_t ModemTrx2[]= {RF_Clear_Interrupt_Flag};
			 trx_spi_sendcmdwithreply(ModemTrx2,&r,4,9);
			 
		 	 LED_red_ClrVal((void *)0);
		 	 //change the state to sleep
		 	 	  write[0]=0x34;
		 	 	  write[1]=0x01;
		 	 	 trx_spi_sendcmdwithreply(write,&r,2,1);
		 	 	 
		 	 	 
		 	 }
return 1;}

int trx_receive()
{	
	LED_red_SetVal((void *)0);
			 	 //change the state to sleep
	uint32_t intr[]={RF_Clear_Interrupt_Flag};
	
	trx_sendcmdnoreply(intr,4);
	
	uint32_t write[2],r;	 	 	
		write[0]=0x34;
			 	 	  write[1]=0x08;
			 	 	 trx_spi_sendcmdwithreply(write,&r,2,1);
	while(1)
	{
	uint32_t rx_buf[8];
	rx_buf[0]=0x32;
	rx_buf[1]=0;
	rx_buf[2]=0x00;
	rx_buf[3]=0x00;
	rx_buf[4]=8;
	rx_buf[5]=0x00;
	rx_buf[6]=0x03;
	rx_buf[7]=0x03;
	trx_sendcmdnoreply(rx_buf,8);
	while(TRX_nIRQ_GetVal((void *)0))
	{
		
	}
	LED_red_ClrVal((void *)0);
	}
return 1;

}
